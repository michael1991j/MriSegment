/*
 * FindCartilage.cpp
 *
 *  Created on: Apr 27, 2014
 *      Author: mri
 */


#include "FindCartilage.h"
#include "MRICommon.h"
FindCartilage::FindCartilage(std::vector< MRICommon *> * ImageStacks , std::vector<LabeledResults *> * LabeledOutput, int id  )  {
	// TODO Auto-generated constructor stub
this->ImageStacks = ImageStacks;
this->LabeledOutput = LabeledOutput;
this->id = id;
}

FindCartilage::~FindCartilage() {
	// TODO Auto-generated destructor stub
}

void FindCartilage::FindBlobs(const cv::Mat &binary, std::vector < std::vector<cv::Point2i> > &blobs)
{
	blobs.clear();

	    // Fill the label_image with the blobs
	    // 0  - background
	    // 1  - unlabelled foreground
	    // 2+ - labelled foreground

	    cv::Mat label_image;
	    binary.convertTo(label_image, CV_32SC1);

	    int label_count = 2; // starts at 2 because 0,1 are used already

	    for(int y=0; y < label_image.rows; y++) {
	        int *row = (int*)label_image.ptr(y);
	        for(int x=0; x < label_image.cols; x++) {
	            if(row[x] != 1) {
	                continue;
	            }

	            cv::Rect rect;
	            cv::floodFill(label_image, cv::Point(x,y), label_count, &rect, 0, 0, 4);

	            std::vector <cv::Point2i> blob;

	            for(int i=rect.y; i < (rect.y+rect.height); i++) {
	                int *row2 = (int*)label_image.ptr(i);
	                for(int j=rect.x; j < (rect.x+rect.width); j++) {
	                    if(row2[j] != label_count) {
	                        continue;
	                    }

	                    blob.push_back(cv::Point2i(j,i));
	                }
	            }

	            blobs.push_back(blob);

	            label_count++;
	        }
}
}

void FindCartilage::Setup()
{
 MRICommon *  fat = this->ImageStacks->at(FATSPGR);                                    // Wait for a keystroke in the window    waitKey(0);
 MRICommon *  water = this->ImageStacks->at(WATERSPGR);                                    // Wait for a keystroke in the window    waitKey(0);

 img = water->Data->Coronial->at(this->id)->Slice - fat->Data->Coronial->at(this->id)->Slice ;
img.convertTo(img, CV_8UC1, 0.09);

imshow("w",img);

}
bool FindCartilage::inrange( std::vector<cv::Point2i >  * points)
{

    for(int i =0; i< points->size(); i++)
    {

        if( (points->at(i).x >40)&& (points->at(i).x <90) &&  (points->at(i).y >270) && (points->at(i).y<360))
           return true;
    }
    return false;

}

void FindCartilage::Preprocess()
{
	GaussianBlur ( img, img, Size(7,7),0,0 );
	medianBlur ( img, img, 3 );

}

void FindCartilage::Segment()
{
	  cv::threshold(img, img, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);



}


void FindCartilage::PostSegmentProcess()
{


}

void FindCartilage::Label()
{

}


void FindCartilage::PostProcess()
{


}



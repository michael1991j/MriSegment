/*
 * FindBoneFemurTrans.cpp
 *
 *  Created on: Apr 23, 2014
 *      Author: mri
 */

#include "FindBoneFemurTrans.h"
#include "MRICommon.h"
FindBoneFemurTrans::FindBoneFemurTrans(std::vector< MRICommon *> * ImageStacks , std::vector<LabeledResults *> * LabeledOutput, int id  )  {
	// TODO Auto-generated constructor stub
this->ImageStacks = ImageStacks;
this->LabeledOutput = LabeledOutput;
this->id = id;
}

FindBoneFemurTrans::~FindBoneFemurTrans() {
	// TODO Auto-generated destructor stub
}

void FindBoneFemurTrans::FindBlobs(const cv::Mat &binary, std::vector < std::vector<cv::Point2i> > &blobs)
{
	blobs.clear();

	    // Fill the label_image with the blobs
	    // 0  - background
	    // 1  - unlabelled foreground
	    // 2+ - labelled foreground

	    cv::Mat label_image;
	    binary.convertTo(label_image, CV_32SC1);

	    int label_count = 2; // starts at 2 because 0,1 are used already

	    for(int y=0; y < label_image.rows; y++) {
	        int *row = (int*)label_image.ptr(y);
	        for(int x=0; x < label_image.cols; x++) {
	            if(row[x] != 1) {
	                continue;
	            }

	            cv::Rect rect;
	            cv::floodFill(label_image, cv::Point(x,y), label_count, &rect, 0, 0, 4);

	            std::vector <cv::Point2i> blob;

	            for(int i=rect.y; i < (rect.y+rect.height); i++) {
	                int *row2 = (int*)label_image.ptr(i);
	                for(int j=rect.x; j < (rect.x+rect.width); j++) {
	                    if(row2[j] != label_count) {
	                        continue;
	                    }

	                    blob.push_back(cv::Point2i(j,i));
	                }
	            }

	            blobs.push_back(blob);

	            label_count++;
	        }
}
}

void FindBoneFemurTrans::Setup()
{
 MRICommon *  fat = this->ImageStacks->at(FATCUBE);                                    // Wait for a keystroke in the window    waitKey(0);
 MRICommon *  water = this->ImageStacks->at(WATERCUBE);                                    // Wait for a keystroke in the window    waitKey(0);

 img = fat->Data->Transversal->at(this->id)->Slice -water->Data->Transversal->at(this->id)->Slice;
img.convertTo(img, CV_8UC1, 0.03);

}
bool FindBoneFemurTrans::inrange( std::vector<cv::Point2i >  * points)
{

    for(int i =0; i< points->size(); i++)
    {

        if( (points->at(i).x >170)&& (points->at(i).x <250) &&  (points->at(i).y >90) && (points->at(i).y<150))
           return true;
    }
    return false;

}

void FindBoneFemurTrans::Preprocess()
{
	GaussianBlur ( img, img, Size(7,7),0,0 );
	medianBlur ( img, img, 3 );

}

void FindBoneFemurTrans::Segment()
{
	int lowThreshold=5;
	int max = 27;
	int kernel_size = 3;
	Canny( img, img, lowThreshold, max, kernel_size );

}

void FindBoneFemurTrans::PostSegmentProcess()
{
    cv::Mat output = cv::Mat::zeros(img.size(), CV_8UC3);
    cv::Mat binary ;
    cv::adaptiveThreshold(img,binary,  1.0,CV_ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY,21,-0.8 );
	    cv::imshow("b", binary);
	    int size= 1;
	    int type = MORPH_ELLIPSE;
	    Mat element = getStructuringElement( type,
	                                         Size( 2*size, 2*size ),
	                                         Point( size, size ) );
	cv::dilate(binary,binary,element);

    std::vector < std::vector<cv::Point2i > > blobs;
	FindBlobs(binary, blobs);
    cout << "get out of your mind : "<< blobs.size() << "lets fucking lose it \n";
	if (blobs.size() == 0)
	{
	cout << "\nthe blob size was zero \n";
		return;
	}
		int Max =0;
	int Maxcount =0;
	int i =0;
	for(i=0; i < blobs.size(); i++) {

	      if(blobs[i].size() > 200)
	        {
	    	  if(inrange(&blobs[i]))
	    	 	          {
	    	 	int pointsintherange  = 0;
	    	 	  for(size_t j=0; j < blobs[i].size(); j++) {
	    	 	        if(( blobs[i][j].x >170)&& (blobs[i][j].x <250) &&  (blobs[i][j].y >90) && (blobs[i][j].y<150))
	    	 			pointsintherange++;
	    	 	       }

	    	 	if(Maxcount<pointsintherange)
	    	 		    Max = i;
	    	 		    Maxcount = pointsintherange;
	    	 	          }
	    	 	        }
	    		  }
	i=Max;
	unsigned char r = 255 * (rand()/(1.0 + RAND_MAX));
			unsigned char g = 255 * (rand()/(1.0 + RAND_MAX));
			unsigned char b = 255 * (rand()/(1.0 + RAND_MAX));
		for(size_t j=0; j < blobs[i].size(); j++) {


			int x = blobs[i][j].x;
			int y = blobs[i][j].y;

			output.at<cv::Vec3b>(y,x)[0] = b;
			output.at<cv::Vec3b>(y,x)[1] = g;
			output.at<cv::Vec3b>(y,x)[2] = r;
              PointXYZ point( x, y*2, id);
			   	    	this->LabeledOutput->at(BONE)->cloud->push_back(point);
	}

 	    cv::imshow("binary", output);
	    waitKey(0);

   	 	int edgeThresh = 1;
   	 	int lowThreshold;
   	 	int const max_lowThreshold = 500;
   	 	int ratio = 3;
   	 	int kernel_size = 3;
   	 	char* window_name = "Edge Map";




}

void FindBoneFemurTrans::Label()
{

}


void FindBoneFemurTrans::PostProcess()
{

}


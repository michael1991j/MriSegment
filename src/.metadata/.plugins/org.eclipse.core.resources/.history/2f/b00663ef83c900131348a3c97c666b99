#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <iostream>
#include "mriscene.h"

#include <sstream>
#include <QGraphicsPixmapItem>

#include <memory>
#include <list>

using namespace std;

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    ProcessDicom("./I0074.dcm");
      this->scene = new MriScene(this);
    this->Manualscene = new  MriManuelScene(this);
    QGraphicsPixmapItem * p = scene->addPixmap(QPixmap("/home/michael/Dropbox/MRI Segmentation/Image Dump/Sagittal/Image_31.jpg"));

    ui->myGraphicsView->setScene(scene);

    ui->myGraphicsView->fitInView(p, Qt::KeepAspectRatio);
    ui->myGraphicsView->scale(25,25);

    ui->ManualGraphicView->setScene(this->Manualscene);
 ui->ManualGraphicView->fitInView(this->Manualscene->sceneRect(), Qt::KeepAspectRatio );



}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::ProcessDicom(char * path)
{

    try
    {


        // Separate the extension from the file name
            std::string outputFileName = "./a.jpg";
        std::string extension;
        size_t dotPos(outputFileName.rfind('.'));
        if(dotPos != outputFileName.npos)
        {
            extension = outputFileName.substr(dotPos);
            outputFileName.erase(dotPos);
        }
        else
        {
            extension = ".jpg";
        }

                ptr<dataSet> loadedDataSet;

                try
                {

                    // Open the file containing the dicom dataset
                    ptr<puntoexe::stream> inputStream(new puntoexe::stream);
                    inputStream->openFile(path, std::ios_base::in);

                    // Connect a stream reader to the dicom stream. Several stream reader
                    //  can share the same stream
                    ptr<puntoexe::streamReader> reader(new streamReader(inputStream));

                    // Get a codec factory and let it use the right codec to create a dataset
                    //  from the input stream
                    ptr<codecs::codecFactory> codecsFactory(codecs::codecFactory::getCodecFactory());
                    loadedDataSet = codecsFactory->load(reader, 2048);


                    // Get the first image. We use it in case there isn't any presentation VOI/LUT
                    //  and we have to calculate the optimal one
                    ptr<image> dataSetImage(loadedDataSet->getImage(0));
                    imbxUint32 width, height;
                    dataSetImage->getSize(&width, &height);


                    // Build the transforms chain
                    ptr<transforms::transformsChain> chain(new transforms::transformsChain);

                    ptr<transforms::modalityVOILUT> modalityVOILUT(new transforms::modalityVOILUT(loadedDataSet));
                    chain->addTransform(modalityVOILUT);

                    ptr<transforms::colorTransforms::colorTransformsFactory> colorFactory(transforms::colorTransforms::colorTransformsFactory::getColorTransformsFactory());
                    if(colorFactory->isMonochrome(dataSetImage->getColorSpace()))
                    {
                        // Convert to MONOCHROME2 if a modality transform is not present
                        ////////////////////////////////////////////////////////////////
                        if(modalityVOILUT->isEmpty())
                        {
                            ptr<transforms::colorTransforms::colorTransform> monochromeColorTransform(colorFactory->getTransform(dataSetImage->getColorSpace(), L"MONOCHROME2"));
                            if(monochromeColorTransform != 0)
                            {
                                chain->addTransform(monochromeColorTransform);
                            }
                        }

                        ptr<transforms::VOILUT> presentationVOILUT(new transforms::VOILUT(loadedDataSet));
                        imbxUint32 firstVOILUTID(presentationVOILUT->getVOILUTId(0));
                        if(firstVOILUTID != 0)
                        {
                            presentationVOILUT->setVOILUT(firstVOILUTID);
                        }
                        else
                        {
                            // Run the transform on the first image
                            ///////////////////////////////////////
                            ptr<image> temporaryImage = chain->allocateOutputImage(dataSetImage, width, height);
                            chain->runTransform(dataSetImage, 0, 0, width, height, temporaryImage, 0, 0);

                            // Now find the optimal VOILUT
                            //////////////////////////////
                            presentationVOILUT->applyOptimalVOI(temporaryImage, 0, 0, width, height);
                        }
                        chain->addTransform(presentationVOILUT);
                    }

                    std::wstring initialColorSpace;
                    if(chain->isEmpty())
                    {
                        initialColorSpace = dataSetImage->getColorSpace();
                    }
                    else
                    {
                        ptr<image> startImage(chain->allocateOutputImage(dataSetImage, 1, 1));
                        initialColorSpace = startImage->getColorSpace();
                    }

                    // Color transform to YCrCb
                    ptr<transforms::colorTransforms::colorTransform> colorTransform(colorFactory->getTransform(initialColorSpace, L"YBR_FULL"));
                    if(colorTransform != 0)
                    {
                        chain->addTransform((colorTransform));
                    }

                    ptr<image> finalImage(new image);
                    finalImage->create(width, height, image::depthU8, L"YBR_FULL", 7);

                    // Scan through the frames
                    for(imbxUint32 frameNumber(0); ; ++frameNumber)
                    {
                        if(frameNumber != 0)
                        {
                            dataSetImage = loadedDataSet->getImage(frameNumber);
                        }


                        if(chain->isEmpty() && dataSetImage->getDepth() != finalImage->getDepth() && dataSetImage->getHighBit() != finalImage->getHighBit())
                        {
                            chain->addTransform(new transforms::transformHighBit);
                        }

                        if(!chain->isEmpty())
                        {
                            chain->runTransform(dataSetImage, 0, 0, width, height, finalImage, 0, 0);
                        }
                        else
                        {
                            finalImage = dataSetImage;
                        }

                        // Open a stream for the jpeg
                        const std::wstring jpegTransferSyntax(L"1.2.840.10008.1.2.4.50");
                        std::ostringstream jpegFileName;
                        jpegFileName << outputFileName;

                        jpegFileName << extension;
                        ptr<puntoexe::stream> jpegStream(new puntoexe::stream);
                        jpegStream->openFile(jpegFileName.str(), std::ios_base::out | std::ios_base::trunc);
                        ptr<puntoexe::streamWriter> jpegWriter(new streamWriter(jpegStream));
                        ptr<codecs::codec> outputCodec(codecsFactory->getCodec(jpegTransferSyntax));

                        // Write the jpeg image to the stream
                        outputCodec->setImage(jpegWriter, finalImage, jpegTransferSyntax, codecs::codec::veryHigh,
                                "OB", 8, false, false, false, false);

                    }

        }
        catch(dataSetImageDoesntExist&)
        {
            // Ignore this exception. It is thrown when we reach the
            //  end of the images list
            exceptionsManager::getMessage();
        }
    }
    catch(...)
    {
        std::wcout << exceptionsManager::getMessage();
    }


}

void MainWindow::on_pushButton_3_clicked()
{
    this->scene->outputregion();
}
void MainWindow::On_tree_itemclicked()
{
    int rownum  = ui->treeWidget->currentIndex().row();
    this->Manualscene->settagetimage(this->MRIData->sagtical->at(rownum),(Record *)&(this->Datahandel->Records->at(rownum)));

qDebug() << rownum;

}

void MainWindow::on_LoadDirforManual_clicked()
{
QStringList files = QFileDialog::getOpenFileNames(
                           0,
                           "Select one or more files to open",
                           "/home",
                           "Images (*.png *.dcm *.jpg)");
this->MRIData = new MriCommon();
this->Datahandel = new RecordHandel();

this->MRIData->LoadImages(&files);
this->MRIData->ToTransversal();


ui->treeWidget->setColumnCount(1);
QList<QTreeWidgetItem *> items;
for (int i = 0; i < this->MRIData->sagtical->size(); ++i)
{
      Record r;
      r.Filename =  QString::number(i);
      r.Z =i;
      r.index= i;
      this->Datahandel->Records->append(r);
      QFileInfo fi( QString::number(i));

      items.append(new QTreeWidgetItem((QTreeWidget*)0, QStringList( QString::number(i))));
}

ui->treeWidget->insertTopLevelItems(0, items);
ui->treeWidget->setCurrentIndex(ui->treeWidget->model()->index(0,0));
this->Manualscene->settagetimage(this->MRIData->sagtical->at(0),(Record *)&(this->Datahandel->Records->at(0)));
connect(ui->treeWidget,SIGNAL(itemSelectionChanged()),this,SLOT(On_tree_itemclicked()));
}

void MainWindow::on_zoomin_clicked()
{
ui->ManualGraphicView->scale(2,2);
}

void MainWindow::on_zoomout_clicked()
{
    ui->ManualGraphicView->scale(0.5,0.5);

}

void MainWindow::on_Clear_clicked()
{
   this->Manualscene->clearpath();
}

void MainWindow::on_outputpcd_clicked()
{
    qDebug() << this->Datahandel->OutputFinalPCDFile();
    ui->textBrowser->setText(this->Datahandel->OutputFinalPCDFile());
}
